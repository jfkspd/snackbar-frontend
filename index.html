<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Snack Bar — Connectivity Test</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body{font:16px system-ui, sans-serif; margin:24px;}
      .ok{color:#065f46} .warn{color:#7f1d1d}
      code{background:#f3f4f6; padding:2px 6px; border-radius:6px}
    </style>
  </head>
  <body>
    <h1>Snack Bar — Connectivity Test</h1>
    <p>If you can read this on SCUSD Wi-Fi, static hosting is OK ✅</p>
    <h2>Fetch Test</h2>
    <p id="status">Running fetch test…</p>

    <label for="q">Search</label>
<input id="q" type="search" placeholder="e.g., chips, soda, 0003" 
       style="width: min(520px, 95%); padding: 8px; margin: 8px 0; font-size: 16px;">

<h2>Items</h2>
<div id="items"></div>

<script>
/** Use your working CSV link */
const ITEMS_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTTtlEwo0hKcYdsMdjhp71Wq1NWDTEwIkdytSm_E1EQfv1x8FHx8sEzyhQoym44_RX2mp2FXvN3jCwf/pub?gid=0&single=true&output=csv';

const statusEl = document.getElementById('status');
const itemsEl  = document.getElementById('items');
const qInput   = document.getElementById('q');

let ALL_ITEMS = [];
let VIEW = [];

run().catch(e => {
  // Top-level catch fallback
  statusEl.innerHTML = `<span class="warn">Script error</span> — ${e && e.message || e}`;
  console.error(e);
});

async function run(){
  log('Fetching Items…');

  // Step 1: fetch + dump HTTP status and first bytes
  const { ok, head, text } = await fetchTextWithStatus(ITEMS_CSV_URL);
  log(`Response: ${head}`, ok ? 'ok' : 'warn');
  log(`<small>First 160 chars:</small><pre>${escapeHTML(text.slice(0,160))}</pre>`);

  if (!ok) throw new Error(`Request not OK (${head})`);

  // Step 2: parse CSV
  const rows = parseCSV(text);
  log(`Parsed ${rows.length} CSV rows.`, rows.length ? 'ok' : 'warn');
  if (!rows.length) throw new Error('CSV is empty');

  // Step 3: map to items
  ALL_ITEMS = rowsToItems(rows);
  VIEW = ALL_ITEMS.slice();
  statusEl.innerHTML = `<span class="ok">Fetched & parsed!</span> Found <strong>${ALL_ITEMS.length}</strong> active items.`;

  // Step 4: render + wire search
  renderItems(VIEW);
  wireSearch();
}

function log(msg, klass){
  const line = document.createElement('div');
  if (klass) line.className = klass;
  line.innerHTML = msg;
  statusEl.appendChild(line);
}

async function fetchTextWithStatus(url){
  try{
    const res = await fetch(url, { cache: 'no-store' });
    const head = `HTTP ${res.status} ${res.statusText}`;
    const text = await res.text();
    return { ok: res.ok, head, text };
  }catch(err){
    return { ok:false, head:`Network error`, text:String(err && err.message || err) };
  }
}

/** CSV parser that handles quoted commas/newlines */
function parseCSV(text){
  const rows = [];
  let i=0, f='', r=[], inQ=false;
  const pushF=()=>{ r.push(f); f=''; };
  const pushR=()=>{ rows.push(r); r=[]; };
  while(i<text.length){
    const c=text[i];
    if(inQ){
      if(c==='"'){
        if(text[i+1]==='"'){ f+='"'; i+=2; continue; }
        inQ=false; i++; continue;
      }
      f+=c; i++; continue;
    }
    if(c==='"'){ inQ=true; i++; continue; }
    if(c===','){ pushF(); i++; continue; }
    if(c==='\r'){ i++; continue; }
    if(c==='\n'){ pushF(); pushR(); i++; continue; }
    f+=c; i++;
  }
  pushF(); if(r.length) pushR();
  return rows;
}

/** Map rows -> items using header names (case-insensitive) */
function rowsToItems(rows){
  const headers = rows[0].map(h => String(h).trim().toLowerCase());
  const idx = {
    item_id: headers.indexOf('item_id'),
    name:    headers.indexOf('name'),
    price:   headers.indexOf('price'),
    active:  headers.indexOf('active')
  };
  const missing = Object.entries(idx).filter(([,i]) => i === -1).map(([k]) => k);
  if(missing.length){
    throw new Error('Missing columns: ' + missing.join(', ') + ' (need item_id, name, price, active)');
  }
  return rows.slice(1)
    .map(row => ({
      item_id: String(row[idx.item_id] ?? '').trim(),
      name:    String(row[idx.name] ?? '').trim(),
      price:   Number(row[idx.price]),
      active:  toBool(row[idx.active])
    }))
    .filter(it => it.active && it.item_id && Number.isFinite(it.price))
    .sort((a,b) => a.name.localeCompare(b.name));
}

function toBool(v){
  const s = String(v).trim().toLowerCase();
  return v === true || s === 'true' || s === '1' || s === 'yes';
}

function renderItems(items){
  if(!items.length){
    itemsEl.innerHTML = '<p class="warn">No matching items.</p>';
    return;
  }
  const list = items.map(it =>
    `<li><code>${esc(it.item_id)}</code> — ${esc(it.name)} — $${it.price.toFixed(2)}</li>`
  ).join('');
  itemsEl.innerHTML = `<p><strong>${items.length}</strong> items shown</p><ul>${list}</ul>`;
}

function wireSearch(){
  let t;
  qInput.addEventListener('input', () => {
    clearTimeout(t);
    t = setTimeout(applyFilter, 120);
  });
}

function applyFilter(){
  const needle = (qInput.value || '').trim().toLowerCase();
  if(!needle){
    VIEW = ALL_ITEMS.slice();
    renderItems(VIEW);
    return;
  }
  VIEW = ALL_ITEMS.filter(it =>
    it.name.toLowerCase().includes(needle) ||
    String(it.item_id).toLowerCase().includes(needle)
  );
  renderItems(VIEW);
}

function esc(s){
  return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
}
function escapeHTML(s){
  return String(s).replace(/[<>&]/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;'}[c]));
}
</script>


  </body>
</html>
