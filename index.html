<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Snack Bar — Connectivity Test</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body{font:16px system-ui, sans-serif; margin:24px;}
      .ok{color:#065f46} .warn{color:#7f1d1d}
      code{background:#f3f4f6; padding:2px 6px; border-radius:6px}
    </style>
  </head>
  <body>
    <h1>Snack Bar — Connectivity Test</h1>
    <p>If you can read this on SCUSD Wi-Fi, static hosting is OK ✅</p>
    <h2>Fetch Test</h2>
    <p id="status">Running fetch test…</p>

    <label for="q">Search</label>
<input id="q" type="search" placeholder="e.g., chips, soda, 0003" 
       style="width: min(520px, 95%); padding: 8px; margin: 8px 0; font-size: 16px;">

<h2>Items</h2>
<div id="items"></div>

<script>
/** Use your working CSV link */
const ITEMS_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTTtlEwo0hKcYdsMdjhp71Wq1NWDTEwIkdytSm_E1EQfv1x8FHx8sEzyhQoym44_RX2mp2FXvN3jCwf/pub?gid=0&single=true&output=csv';

const statusEl = document.getElementById('status');
const itemsEl  = document.getElementById('items');
const qInput   = document.getElementById('q');

let ALL_ITEMS = [];  // parsed & active items
let VIEW = [];       // current filtered view

run().catch(e => {
  statusEl.innerHTML = `<span class="warn">Script error</span> — ${e && e.message || e}`;
  console.error(e);
});

async function run(){
  setStatus('Fetching Items…');

  try{
    const res = await fetch(ITEMS_CSV_URL, { cache:'no-store' });
    if(!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
    const csv = await res.text();

    const rows = parseCSV(csv);

    // Debug: show headers + first row so we can verify shape
    if (rows.length) {
      statusEl.innerHTML += `<div><small>Headers:</small> <code>${escapeHTML(rows[0].join(' | '))}</code></div>`;
    }
    if (rows.length > 1) {
      statusEl.innerHTML += `<div><small>Row1:</small> <code>${escapeHTML(rows[1].join(' | '))}</code></div>`;
    }
    if(!rows.length) throw new Error('CSV is empty');

    ALL_ITEMS = rowsToItems(rows);
    VIEW = ALL_ITEMS.slice(); // start with all

    statusEl.innerHTML = `<span class="ok">Fetched & parsed!</span> Found <strong>${ALL_ITEMS.length}</strong> active items.`;

    renderItems(VIEW);
    wireSearch();
  }catch(err){
    statusEl.innerHTML = `<span class="warn">Fetch FAILED</span> — ${err && err.message || err}`;
  }
}

/** CSV parser that handles quoted commas/newlines */
function parseCSV(text){
  const rows = [];
  let i=0, f='', r=[], inQ=false;
  const pushF=()=>{ r.push(f); f=''; };
  const pushR=()=>{ rows.push(r); r=[]; };
  while(i<text.length){
    const c=text[i];
    if(inQ){
      if(c==='"'){
        if(text[i+1]==='"'){ f+='"'; i+=2; continue; }
        inQ=false; i++; continue;
      }
      f+=c; i++; continue;
    }
    if(c==='"'){ inQ=true; i++; continue; }
    if(c===','){ pushF(); i++; continue; }
    if(c==='\r'){ i++; continue; }
    if(c==='\n'){ pushF(); pushR(); i++; continue; }
    f+=c; i++;
  }
  pushF(); if(r.length) pushR();
  return rows;
}

/** Helpers */
function parseMoney(v){
  // Strip everything except digits, dot, minus
  const n = Number(String(v).replace(/[^\d.-]/g, ''));
  return Number.isFinite(n) ? n : NaN;
}

function toBool(v){
  const s = String(v).trim().toLowerCase();
  return v === true || s === 'true' || s === '1' || s === 'yes' || s === 'y';
}

function escapeHTML(s){
  return String(s).replace(/[<>&]/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;'}[c]));
}

function setStatus(msg){ statusEl.textContent = msg; }

/** Map rows -> items using header names (case-insensitive) */
function rowsToItems(rows){
  const headers = rows[0].map(h => String(h).trim().toLowerCase());
  const idx = {
    item_id: headers.indexOf('item_id'),
    name:    headers.indexOf('name'),
    price:   headers.indexOf('price'),
    active:  headers.indexOf('active')
  };
  const missing = Object.entries(idx).filter(([,i]) => i === -1).map(([k]) => k);
  if(missing.length){
    throw new Error('Missing columns: ' + missing.join(', ') + ' (need item_id, name, price, active)');
  }
  return rows.slice(1)
    .map(row => ({
      item_id: String(row[idx.item_id] ?? '').trim(),
      name:    String(row[idx.name] ?? '').trim(),
      price:   parseMoney(row[idx.price]),
      active:  toBool(row[idx.active])
    }))
    .filter(it => it.active && it.item_id && Number.isFinite(it.price))
    .sort((a,b) => a.name.localeCompare(b.name));
}

/** Simple client-side render */
function renderItems(items){
  if(!items.length){
    itemsEl.innerHTML = '<p class="warn">No matching items.</p>';
    return;
  }
  const list = items.map(it =>
    `<li><code>${escapeHTML(it.item_id)}</code> — ${escapeHTML(it.name)} — $${it.price.toFixed(2)}</li>`
  ).join('');
  itemsEl.innerHTML = `<p><strong>${items.length}</strong> items shown</p><ul>${list}</ul>`;
}

/** Search wiring with debounce */
function wireSearch(){
  let t;
  qInput.addEventListener('input', () => {
    clearTimeout(t);
    t = setTimeout(applyFilter, 120);
  });
}

function applyFilter(){
  const needle = (qInput.value || '').trim().toLowerCase();
  if(!needle){
    VIEW = ALL_ITEMS.slice();
    renderItems(VIEW);
    return;
  }
  VIEW = ALL_ITEMS.filter(it =>
    it.name.toLowerCase().includes(needle) ||
    String(it.item_id).toLowerCase().includes(needle)
  );
  renderItems(VIEW);
}
</script>


  </body>
</html>
